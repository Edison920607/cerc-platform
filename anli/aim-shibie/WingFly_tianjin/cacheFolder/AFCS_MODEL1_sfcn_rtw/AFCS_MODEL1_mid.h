/*
 * AFCS_MODEL1_mid.h
 *
 * Code generation for model "AFCS_MODEL1_sf".
 *
 * Model version              : 1.995
 * Simulink Coder version : 8.10 (R2016a) 10-Feb-2016
 * C source code generated on : Wed Aug 11 17:17:39 2021
 *
 * Target selection: rtwsfcn.tlc
 * Note: GRT includes extra infrastructure and instrumentation for prototyping
 * Embedded hardware selection: ARM Compatible->ARM Cortex
 * Emulation hardware selection:
 *    Differs from embedded hardware (MATLAB Host)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 *
 * SOURCES: AFCS_MODEL1_sf.c AFCS_MODEL1_CodeReuseSubsystem.c
 */

#include "simstruc.h"
#include "AFCS_MODEL1_sf.h"
#if defined(MATLAB_MEX_FILE) || defined(RT_MALLOC)

static int_T RegNumInputPorts(SimStruct *S, int_T nInputPorts)
{
  _ssSetNumInputPorts(S,nInputPorts);
  return true;
}

static int_T RegNumOutputPorts(SimStruct *S, int_T nOutputPorts)
{
  _ssSetNumOutputPorts(S,nOutputPorts);
  return true;
}

static int_T FcnSetErrorStatus(const SimStruct *S, DTypeId arg2)
{
  static char msg[256];
  if (strlen(ssGetModelName(S)) < 128) {
    sprintf(msg,
            "S-function %s does not have a tlc file. It cannot use macros that access regDataType field in simstruct.",
            ssGetModelName(S));
  } else {
    sprintf(msg,
            "A S-function does not have a tlc file. It cannot use macros that access regDataType field in simstruct.");
  }

  ssSetErrorStatus(S, msg);
  UNUSED_PARAMETER(arg2);
  return 0;
}

#endif

/* Instance data for model: AFCS_MODEL1 */
void *AFCS_MODEL1_malloc(SimStruct *rts)
{
  /* Local SimStruct for the generated S-Function */
  LocalS *lS = (LocalS *) malloc(sizeof(LocalS));
  ss_VALIDATE_MEMORY(rts,lS);
  (void) memset((char *) lS, 0,
                sizeof(LocalS));
  ssSetUserData(rts, lS);

  /* block I/O */
  {
    void *b = malloc(sizeof(B_AFCS_MODEL1_T));
    ss_VALIDATE_MEMORY(rts,b);
    ssSetLocalBlockIO(rts, b);
    (void) memset(b, 0,
                  sizeof(B_AFCS_MODEL1_T));

    {
      ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->FixPtSwitch = (0ULL);
      ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Output = (0ULL);
      ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->FixPtSum1 = (0ULL);
      ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Quaternions[0] = 0.0F;
      ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Quaternions[1] = 0.0F;
      ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Quaternions[2] = 0.0F;
      ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Quaternions[3] = 0.0F;
    }
  }

  _ssSetConstBlockIO(rts, &AFCS_MODEL1_Invariant);

  /* previous zero-crossing states */
  {
    int_T i;
    ZCSigState *zc = (ZCSigState *) malloc(sizeof(PrevZCX_AFCS_MODEL1_T));
    ss_VALIDATE_MEMORY(rts,zc);
    _ssSetPrevZCSigState(rts, zc);
    for (i = 0; i < 2; i++) {
      zc[i] = UNINITIALIZED_ZCSIG;
    }
  }

  /* model checksums */
  ssSetChecksumVal(rts, 0, 3122258030U);
  ssSetChecksumVal(rts, 1, 1365478836U);
  ssSetChecksumVal(rts, 2, 3803939167U);
  ssSetChecksumVal(rts, 3, 1395178863U);

  {
    /* child S-Function registration */
    ssSetNumSFunctions(rts, 170);

    /* register each child */
    {
      SimStruct *childSFunctions;
      SimStruct **childSFunctionPtrs;
      childSFunctions = (SimStruct *) malloc(170 * sizeof(SimStruct));
      ss_VALIDATE_MEMORY(rts,childSFunctions);
      (void) memset((void *)childSFunctions, 0,
                    170*sizeof(SimStruct));
      childSFunctionPtrs = (SimStruct **) malloc(170 * sizeof(SimStruct *));
      ss_VALIDATE_MEMORY(rts,childSFunctionPtrs);
      _ssSetSFunctions(rts, childSFunctionPtrs);

      {
        int_T i;
        for (i = 0; i < 170; i++) {
          _ssSetSFunction(rts, i, &childSFunctions[i]);
        }
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S174>/Generated S-Function (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 0);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion3_h;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch4;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/FixthrustL/ lag filter/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 147))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 148))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 374))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 375))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S186>/Generated S-Function (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 1);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum_hq;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_c));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/Saturation Limiter1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S188>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 2);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_c;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant1_Value_i;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_c5));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S185>/Generated S-Function (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 3);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_j;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_c5;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_n));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/Lead lag/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 149))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 150))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 376))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 377))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S187>/Generated S-Function (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 4);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_n;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled110;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_g));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/Saturation Limiter3/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S189>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 5);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_n;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant2_Value_c;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_j));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S184>/Generated S-Function (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 6);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_j;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add2;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add2;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add_g1;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add1;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_j;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_g));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/Integrator Limited/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 151))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 152))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 378))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 379))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S183>/Generated S-Function (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 7);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_j;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_b;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_k));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/ lag filter/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 153))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 154))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 380))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 381))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S179>/Generated S-Function (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 8);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum_mj;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_g));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/Saturation Limiter1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S181>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 9);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_g;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant1_Value_i;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_j5));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S178>/Generated S-Function (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 10);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_lt;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_j5;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_e));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/Lead lag/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 155))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 156))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 382))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 383))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S180>/Generated S-Function (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 11);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_e;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled110;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_g));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/Saturation Limiter3/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S182>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 12);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_e;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant2_Value_c;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_b));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S177>/Generated S-Function (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 13);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_lt;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add2_d;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add2_d;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add_l;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add1_g;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_b;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_g));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/Integrator Limited/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 157))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 158))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 384))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 385))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S176>/Generated S-Function (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 14);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_lt;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_k;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_a;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_m));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/ lag filter/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 159))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 160))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 386))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 387))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S92>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 15);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum6;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Saturation Limiter2/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S96>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 16);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant22_Value;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_o));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S93>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 17);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Divide2;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch6_d));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Saturation Limiter3/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S97>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 18);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_o;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_jq));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/gain4/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S89>/Generated S-Function3 (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 19);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion3_c;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum8;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum8;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_jq;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch6_d));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Integrator Limited1/Generated S-Function3");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 162))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 163))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 389))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 390))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S91>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 20);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_j;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_h));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S95>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 21);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_h;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant13_Value_n;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation8));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S90>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 22);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion3_c;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Divide;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Lead lag/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 164))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 165))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 391))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 392))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S94>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 23);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_m;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product_pp;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_b));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Saturation Limiter4/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S87>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 24);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion3_c;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_b;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 166))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 167))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 393))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 394))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S114>/Generated S-Function (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 25);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_m;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product_pp;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_kz));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/NzControl/Saturation Limiter1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S113>/Generated S-Function (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 26);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion_gv;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_kz;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/NzControl/ lag filter/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 168))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 169))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 395))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 396))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S86>/Generated S-Function6 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 27);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_f;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/Generated S-Function6");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S119>/Generated S-Function (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 28);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_n0));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/Saturation Limiter/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S121>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 29);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_n0;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_k1));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S118>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 30);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_p;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant10_Value_a;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_k1;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_m));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/Lead lag/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 170))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 171))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 397))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 398))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S120>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 31);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_m;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_m;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product_pp;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation8));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S117>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 32);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_p;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_e;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_e;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum2_eb;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_d));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/ lag filter1/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 172))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 173))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 399))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 400))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S122>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 33);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_d;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch6_d));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S116>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 34);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_p;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum3_l;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_f));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 174))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 175))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 401))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 402))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S102>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 35);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_l;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_n));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S104>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 36);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_n;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant13_Value_n;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_b1));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S105>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 37);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_b1;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_h));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/gain4/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S100>/Generated S-Function3 (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 38);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_c;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant19_Value;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant76_Value;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_h;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation8));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/Integrator Limited1/Generated S-Function3");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 176))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 177))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 403))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 404))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S101>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 39);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_c;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Divide_e;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_j));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/Lead lag/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 178))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 179))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 405))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 406))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S103>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 40);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_j;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_m;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product_pp;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_e));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/Saturation Limiter2/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S98>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 41);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_c;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_e;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_c));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 180))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 181))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 407))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 408))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S109>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 42);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_i;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_g));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S111>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 43);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_g;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant13_Value_n;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_nx));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S112>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 44);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_nx;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_d));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/gain4/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S107>/Generated S-Function3 (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 45);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion4_k;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant19_Value;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant76_Value;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_d;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation8));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/Integrator Limited1/Generated S-Function3");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 182))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 183))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 409))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 410))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S108>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 46);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion4_k;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Divide_ez;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_b));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/Lead lag/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 184))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 185))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 411))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 412))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S110>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 47);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_b;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_m;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product_pp;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_l));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/Saturation Limiter2/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S106>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 48);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion4_k;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_aj;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_l;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_n));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 186))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 187))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 413))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 414))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S81>/Generated S-Function5 (Fader_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 49);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MultiportSwitch2;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MultiportSwitch2;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch9;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->appc));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Fader_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/Fader/Generated S-Function5");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (7 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(7, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 7);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 289))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 290))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 2, 0);
          _ssSetDWork(childS, 2, &((real32_T*) ssGetDWork(rts, 291))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT32);
          ssSetDWorkComplexSignal(childS, 3, 0);
          _ssSetDWork(childS, 3, &((int32_T*) ssGetDWork(rts, 332))[0]);

          /* DWORK4 */
          ssSetDWorkWidth(childS, 4, 1);
          ssSetDWorkDataType(childS, 4,SS_INT32);
          ssSetDWorkComplexSignal(childS, 4, 0);
          _ssSetDWork(childS, 4, &((int32_T*) ssGetDWork(rts, 333))[0]);

          /* DWORK5 */
          ssSetDWorkWidth(childS, 5, 1);
          ssSetDWorkDataType(childS, 5,SS_INT8);
          ssSetDWorkComplexSignal(childS, 5, 0);
          _ssSetDWork(childS, 5, &((int8_T*) ssGetDWork(rts, 517))[0]);

          /* DWORK6 */
          ssSetDWorkWidth(childS, 6, 1);
          ssSetDWorkDataType(childS, 6,SS_INT8);
          ssSetDWorkComplexSignal(childS, 6, 0);
          _ssSetDWork(childS, 6, &((int8_T*) ssGetDWork(rts, 518))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Fader_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Fader_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S130>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 50);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion5_n;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_b));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 189))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 190))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 417))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 418))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S125>/Generated S-Function6 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 51);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_lf;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_h));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/Generated S-Function6");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S134>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 52);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_h;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_c));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/Saturation Limiter/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S135>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 53);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_c;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_hw));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S136>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 54);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_hw;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MinMax));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S137>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 55);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->UnitDelay1_k;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_a));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/gain8/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.005);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S132>/Generated S-Function3 (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 56);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion3_d;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum2_c;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum2_c;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant29_Value;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant30_Value;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum11;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction3));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/Integrator Limited/Generated S-Function3");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 192))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 193))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 419))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 420))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S133>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 57);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion3_d;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum_c;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_f));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/Lead lag/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 194))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 195))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 421))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 422))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S131>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 58);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion3_d;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_f;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_m));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 196))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 197))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 423))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 424))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S155>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 59);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Divide_c;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_o));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Saturation Limiter2/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.005);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S128>/Generated S-Function6 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 60);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum3_g;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_g));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Generated S-Function6");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S154>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 61);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_g;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_m));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S158>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 62);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_m;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled122;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_f));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S152>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 63);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_h;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum4_d;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum4_d;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_f;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation2_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Lead lag1/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 198))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 199))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 425))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 426))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S128>/Generated S-Function1 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 64);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_g;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_hp));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S153>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 65);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_hp;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_oq));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Saturation Limiter/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S156>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 66);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_oq;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ex));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S157>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 67);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ex;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_nh));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S150>/Generated S-Function3 (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 68);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_h;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant29_Value;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant30_Value;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_nh;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation2_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Integrator Limited/Generated S-Function3");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 200))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 201))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 427))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 428))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S151>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 69);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_h;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum_d;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_i));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Lead lag/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 202))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 203))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 429))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 430))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S149>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 70);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_h;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_i;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_dc));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 204))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 205))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 431))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 432))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S145>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 71);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Divide_l;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Saturation Limiter2/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.005);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S127>/Generated S-Function6 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 72);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum3_c;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_a));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Generated S-Function6");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S144>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 73);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_a;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_l1));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S148>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 74);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_l1;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_cv));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S142>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 75);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_p;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum4_i;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum4_i;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_cv;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_c));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Lead lag1/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 206))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 207))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 433))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 434))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S143>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 76);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_c;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation2_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Saturation Limiter/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S127>/Generated S-Function1 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 77);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_ga;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_bh));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S146>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 78);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_bh;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ma));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S147>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 79);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ma;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ck));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S140>/Generated S-Function3 (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 80);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_p;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant29_Value;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant30_Value;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ck;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation2_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Integrator Limited/Generated S-Function3");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 208))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 209))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 435))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 436))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S141>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 81);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_p;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum_mz;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_n));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Lead lag/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 210))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 211))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 437))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 438))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S139>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 82);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_p;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_n;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_cg));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 212))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 213))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 439))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 440))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S164>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 83);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum2_hh;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_n1));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter3/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S168>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 84);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_n1;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled123;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_fb));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/gain3/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S169>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 85);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_fb;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ok));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/gain4/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S160>/Generated S-Function3 (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 86);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion4_g;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ok;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation2_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Integrator Limited1/Generated S-Function3");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 214))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 215))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 441))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 442))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S129>/Generated S-Function6 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 87);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum3_cy;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_h3));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Generated S-Function6");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S162>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 88);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_h3;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_oh));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S167>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 89);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_oh;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_mc));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S161>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 90);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_mc;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation2_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S129>/Generated S-Function1 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 91);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_lk;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_f));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S166>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 92);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_f;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation2_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S159>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 93);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion4_g;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bg;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum_oh;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_mj));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 216))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 217))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 443))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 444))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S123>/Generated S-Function5 (Fader_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 94);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MultiportSwitch2_k;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MultiportSwitch2_k;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch9;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->aprc));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Fader_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/Fader/Generated S-Function5");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (7 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(7, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 7);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 292))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 293))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 2, 0);
          _ssSetDWork(childS, 2, &((real32_T*) ssGetDWork(rts, 294))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT32);
          ssSetDWorkComplexSignal(childS, 3, 0);
          _ssSetDWork(childS, 3, &((int32_T*) ssGetDWork(rts, 334))[0]);

          /* DWORK4 */
          ssSetDWorkWidth(childS, 4, 1);
          ssSetDWorkDataType(childS, 4,SS_INT32);
          ssSetDWorkComplexSignal(childS, 4, 0);
          _ssSetDWork(childS, 4, &((int32_T*) ssGetDWork(rts, 335))[0]);

          /* DWORK5 */
          ssSetDWorkWidth(childS, 5, 1);
          ssSetDWorkDataType(childS, 5,SS_INT8);
          ssSetDWorkComplexSignal(childS, 5, 0);
          _ssSetDWork(childS, 5, &((int8_T*) ssGetDWork(rts, 519))[0]);

          /* DWORK6 */
          ssSetDWorkWidth(childS, 6, 1);
          ssSetDWorkDataType(childS, 6,SS_INT8);
          ssSetDWorkComplexSignal(childS, 6, 0);
          _ssSetDWork(childS, 6, &((int8_T*) ssGetDWork(rts, 520))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Fader_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Fader_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S163>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 95);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Divide_c2;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_nk));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter2/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.005);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S165>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 96);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Divide1_d;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_d));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter4/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S190>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 97);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion_f;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled124;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_k));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 219))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 220))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 446))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 447))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S191>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 98);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion3_l;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled124;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch7;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/ lag filter1/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 221))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 222))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 448))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 449))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S193>/Generated S-Function (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 99);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum3_g5;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_bb));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S198>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 100);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_bb;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_mq));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S199>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 101);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_mq;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled122;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_k5));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S197>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 102);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_e;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_k5;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_h));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/Lead lag1/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 223))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 224))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 450))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 451))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S196>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 103);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_e;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled124;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_h;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_a));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 225))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 226))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 452))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 453))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S204>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 104);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->r_n;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation8));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S203>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 105);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum2_eo;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_ov));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/Saturation Limiter3/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S206>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 106);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_ov;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MinMax));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/gain3/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S194>/Generated S-Function6 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 107);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum3_k;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_aa));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/Generated S-Function6");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S202>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 108);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_aa;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_dm));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S205>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 109);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_dm;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_pk));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S201>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 110);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_j;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_pk;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MinMax));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/Lead lag1/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 227))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 228))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 454))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 455))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S200>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 111);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_j;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled124;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_jf;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_k;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_j));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 229))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 230))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 456))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 457))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S69>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 112);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion_p;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_fz;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_fz;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_pd));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 232))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 233))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 459))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 460))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S70>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 113);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion2_b;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_fz;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_fz;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Gain_k;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_h));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/ lag filter1/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 234))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 235))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 461))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 462))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S77>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 114);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum2_b;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_i));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/Saturation Limiter3/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S79>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 115);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_i;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation2_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/gain3/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S72>/Generated S-Function6 (Res180_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 116);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum3_ca;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_j));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Res180_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/Generated S-Function6");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Res180_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S76>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 117);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction6_j;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_k));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S78>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 118);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_k;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_cq));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S75>/Generated S-Function2 (LeadLagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 119);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_jy;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_fz;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_fz;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_cq;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_m5));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LeadLagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/Lead lag1/Generated S-Function2");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 236))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 237))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 463))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 464))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LeadLagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S74>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 120);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->DataTypeConversion1_jy;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_fz;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_fz;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction2_m5;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_cw));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 238))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 239))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 465))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 466))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S209>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 121);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_lr;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_oi));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/Saturation Limiter/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S208>/Generated S-Function (RateLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 122);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(5, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 5);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReus_b[5];
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled123;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_oi;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(2, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 2);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_o1));
          }

          /* port 1 */
          {
            _ssSetOutputPortNumDimensions(childS, 1, 1);
            ssSetOutputPortWidth(childS, 1, 1);
            _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_o2));
          }
        }

        /* path info */
        _ssSetModelName(childS, "RateLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/Rate Limiter/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (3 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(3, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 3);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 240))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_INT8);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 467))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 468))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "RateLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 1, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);
        _ssSetOutputPortBeingMerged(childS, 1, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S241>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 123);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled126;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation_ll;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation_ll;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation_ll;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation8));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/ lag filter2/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 241))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 242))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 469))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 470))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S245>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 124);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum_ot;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product_pf;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_fe));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain3/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S246>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 125);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_fe;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_gq));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain4/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S239>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 126);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Ny;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Ny;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Ny;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_kq));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 243))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 244))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 471))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 472))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S242>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 127);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_kq;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation8));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S240>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 128);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled126;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation1_o;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation1_o;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation1_o;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_ab));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/ lag filter1/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 245))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 246))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 473))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 474))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S238>/Generated S-Function8 (WashoutFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 129);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation1_o;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation1_o;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_ab;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction8));
          }
        }

        /* path info */
        _ssSetModelName(childS, "WashoutFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/ high pass filter/Generated S-Function8");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 247))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 248))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 475))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 476))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "WashoutFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          WashoutFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S244>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 130);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction8;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant23_Value;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MinMax));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S243>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 131);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum5;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product2_d;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_dc));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S225>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 132);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_dd;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled130;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled131;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_en));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S223>/Generated S-Function7 (RateLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 133);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(5, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 5);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReus_b[4];
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled125;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_en;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(2, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 2);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation8));
          }

          /* port 1 */
          {
            _ssSetOutputPortNumDimensions(childS, 1, 1);
            ssSetOutputPortWidth(childS, 1, 1);
            _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2));
          }
        }

        /* path info */
        _ssSetModelName(childS, "RateLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/Rate Limiter1/Generated S-Function7");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (3 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(3, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 3);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 249))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_INT8);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 477))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 478))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "RateLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 1, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);
        _ssSetOutputPortBeingMerged(childS, 1, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S226>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 134);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_c;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled130;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled131;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_or));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/Saturation Limiter4/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S224>/Generated S-Function7 (RateLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 135);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(5, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 5);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Gain1_o;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled125;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_or;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(2, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 2);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->drint));
          }

          /* port 1 */
          {
            _ssSetOutputPortNumDimensions(childS, 1, 1);
            ssSetOutputPortWidth(childS, 1, 1);
            _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2_i));
          }
        }

        /* path info */
        _ssSetModelName(childS, "RateLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/Rate Limiter3/Generated S-Function7");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (3 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(3, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 3);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 250))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_INT8);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 479))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 480))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "RateLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 1, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);
        _ssSetOutputPortBeingMerged(childS, 1, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S252>/Generated S-Function8 (WashoutFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 136);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction8_p));
          }
        }

        /* path info */
        _ssSetModelName(childS, "WashoutFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/ high pass filter/Generated S-Function8");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 251))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 252))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 481))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 482))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "WashoutFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          WashoutFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S253>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 137);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_e;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_e;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_e;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_e));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/ lag filter/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 253))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 254))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 483))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 484))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S254>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 138);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_ms));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/ lag filter1/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 255))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 256))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 485))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 486))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S259>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 139);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_e;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MinMax));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S260>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 140);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction4_ms;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled123;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation7));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S255>/Generated S-Function9 (NegativePass_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 141);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum2_hd;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation7));
          }
        }

        /* path info */
        _ssSetModelName(childS, "NegativePass_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/ negative pass1/Generated S-Function9");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "NegativePass_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          NegativePass_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S266>/Generated S-Function (WashoutFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 142);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Alfa_j;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Alfa_j;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Alfa_j;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_f5));
          }
        }

        /* path info */
        _ssSetModelName(childS, "WashoutFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim / high pass filter2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 257))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 258))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 487))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 488))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "WashoutFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          WashoutFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S268>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 143);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_f5;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MinMax));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S265>/Generated S-Function8 (WashoutFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 144);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->q_k;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction8_e));
          }
        }

        /* path info */
        _ssSetModelName(childS, "WashoutFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim / high pass filter1/Generated S-Function8");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 259))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 260))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 489))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 490))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "WashoutFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          WashoutFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S269>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 145);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction8_e;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled133;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o1));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /gain10/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S267>/Generated S-Function (NegativePass_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 146);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum12;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_hl));
          }
        }

        /* path info */
        _ssSetModelName(childS, "NegativePass_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim / negative pass1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "NegativePass_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          NegativePass_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S270>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 147);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_hl;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o1));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /gain11/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S272>/Generated S-Function (PositivePass_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 148);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(1, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 1);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum2_n;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_m5));
          }
        }

        /* path info */
        _ssSetModelName(childS, "PositivePass_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /positive pass1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "PositivePass_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          PositivePass_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S271>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 149);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_m5;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->MinMax));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /gain9/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S261>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 150);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction8_p;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation9));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S262>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 151);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum6_j;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product1_j;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_l));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain3/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S258>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 152);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_l;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled130;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled131;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation9));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S263>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 153);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_l;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation9));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain4/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S264>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 154);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->UnitDelay1_c;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_mt));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain8/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.005);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S257>/Generated S-Function3 (IntegratorLimited_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 155);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(7, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 7);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum4_iv;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum4_iv;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add4;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Add5;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }

          /* port 6 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum11_c;
            _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 6, 1);
            ssSetInputPortWidth(childS, 6, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->deint));
          }
        }

        /* path info */
        _ssSetModelName(childS, "IntegratorLimited_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/Integrator Limited/Generated S-Function3");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 263))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 264))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 492))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 493))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "IntegratorLimited_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetInputPortConnected(childS, 6, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
        _ssSetInputPortBufferDstPort(childS, 6, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S250>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 156);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_m;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled130;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled131;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_pc));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/Saturation Limiter4/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S249>/Generated S-Function7 (RateLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 157);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(5, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 5);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Gain_i;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled125;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_pc;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(2, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 2);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->daint));
          }

          /* port 1 */
          {
            _ssSetOutputPortNumDimensions(childS, 1, 1);
            ssSetOutputPortWidth(childS, 1, 1);
            _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2_i2));
          }
        }

        /* path info */
        _ssSetModelName(childS, "RateLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/Rate Limiter3/Generated S-Function7");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (3 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(3, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 3);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 265))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_INT8);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 494))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 495))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "RateLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 1, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);
        _ssSetOutputPortBeingMerged(childS, 1, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S275>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 158);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_i;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_hf));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/sb/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S274>/Generated S-Function7 (RateLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 159);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(5, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 5);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled133;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_hf;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(2, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 2);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation9));
          }

          /* port 1 */
          {
            _ssSetOutputPortNumDimensions(childS, 1, 1);
            ssSetOutputPortWidth(childS, 1, 1);
            _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2_f));
          }
        }

        /* path info */
        _ssSetModelName(childS, "RateLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/sb/Rate Limiter1/Generated S-Function7");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (3 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(3, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 3);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 266))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_INT8);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 496))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 497))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "RateLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 1, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);
        _ssSetOutputPortBeingMerged(childS, 1, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S215>/Generated S-Function4 (LagFilter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 160);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(6, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 6);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled126;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation1_o;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation1_o;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }

          /* port 5 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation_p;
            _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 5, 1);
            ssSetInputPortWidth(childS, 5, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o1));
          }
        }

        /* path info */
        _ssSetModelName(childS, "LagFilter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/NwsBrk/ lag filter2/Generated S-Function4");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (4 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(4, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 4);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 267))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 268))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 498))[0]);

          /* DWORK3 */
          ssSetDWorkWidth(childS, 3, 1);
          ssSetDWorkDataType(childS, 3,SS_INT8);
          ssSetDWorkComplexSignal(childS, 3, 0);
          ssSetDWorkUsedAsDState(childS, 3, 1);
          _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 499))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "LagFilter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetInputPortConnected(childS, 5, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
        _ssSetInputPortBufferDstPort(childS, 5, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S218>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 161);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum_b;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled133;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_ka));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/NwsBrk/gain3/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S217>/Generated S-Function1 (SaturationLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 162);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(3, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 3);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_bw;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product4_o;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Product3_d;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_hx));
          }
        }

        /* path info */
        _ssSetModelName(childS, "SaturationLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/NwsBrk/Saturation Limiter1/Generated S-Function1");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "SaturationLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S216>/Generated S-Function7 (RateLimiter_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 163);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(5, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 5);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            int8_T const **sfcnUPtrs = (int8_T const **)
              malloc(1 * sizeof(int8_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled134;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->dtCAS;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }

          /* port 4 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction1_hx;
            _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 4, 1);
            ssSetInputPortWidth(childS, 4, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(2, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 2);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o1));
          }

          /* port 1 */
          {
            _ssSetOutputPortNumDimensions(childS, 1, 1);
            ssSetOutputPortWidth(childS, 1, 1);
            _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2_k));
          }
        }

        /* path info */
        _ssSetModelName(childS, "RateLimiter_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/NwsBrk/Rate Limiter1/Generated S-Function7");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

        /* work vectors */
        {
          struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *) malloc
            (3 * sizeof(struct _ssDWorkRecord));
          struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
            calloc(3, sizeof(struct _ssDWorkAuxRecord));
          ss_VALIDATE_MEMORY(rts,dWorkRecord);
          ss_VALIDATE_MEMORY(rts,dWorkAuxRecord);
          ssSetSFcnDWork(childS, dWorkRecord);
          ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
          _ssSetNumDWork(childS, 3);

          /* DWORK0 */
          ssSetDWorkWidth(childS, 0, 1);
          ssSetDWorkDataType(childS, 0,SS_SINGLE);
          ssSetDWorkComplexSignal(childS, 0, 0);
          ssSetDWorkUsedAsDState(childS, 0, 1);
          _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 269))[0]);

          /* DWORK1 */
          ssSetDWorkWidth(childS, 1, 1);
          ssSetDWorkDataType(childS, 1,SS_INT8);
          ssSetDWorkComplexSignal(childS, 1, 0);
          ssSetDWorkUsedAsDState(childS, 1, 1);
          _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 500))[0]);

          /* DWORK2 */
          ssSetDWorkWidth(childS, 2, 1);
          ssSetDWorkDataType(childS, 2,SS_INT8);
          ssSetDWorkComplexSignal(childS, 2, 0);
          ssSetDWorkUsedAsDState(childS, 2, 1);
          _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 501))[0]);
        }

        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "RateLimiter_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetInputPortConnected(childS, 4, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortConnected(childS, 1, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);
        _ssSetOutputPortBeingMerged(childS, 1, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
        _ssSetInputPortBufferDstPort(childS, 4, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S279>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 164);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Sum1_o;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_gq4));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/GNCinit1/apinit/lon/gain/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S280>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 165);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation_bq;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled123;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_dw));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/GNCinit1/apinit/lon/gain1/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S281>/Generated S-Function (Gain_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 166);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(2, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 2);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Saturation_bq;
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction_d4));
          }
        }

        /* path info */
        _ssSetModelName(childS, "Gain_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/GNCinit1/apinit/lon/gain2/Generated S-Function");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "Gain_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S306>/Generated S-Function15 (StickGradientDeadZone_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 167);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(4, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 4);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_lo[1];
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant2_Value_o;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction15));
          }
        }

        /* path info */
        _ssSetModelName(childS, "StickGradientDeadZone_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Pilot/Stick Gradient DeadZone2/Generated S-Function15");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "StickGradientDeadZone_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          StickGradientDeadZone_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S305>/Generated S-Function15 (StickGradientDeadZone_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 168);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(4, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 4);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_lo[0];
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant2_Value_o;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction15_i));
          }
        }

        /* path info */
        _ssSetModelName(childS, "StickGradientDeadZone_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Pilot/Stick Gradient DeadZone1/Generated S-Function15");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "StickGradientDeadZone_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          StickGradientDeadZone_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
      }

      /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S304>/Generated S-Function15 (StickGradientDeadZone_sf) */
      {
        SimStruct *childS = ssGetSFunction(rts, 169);

        /* timing info */
        time_T *sfcnPeriod;
        time_T *sfcnOffset;
        int_T *sfcnTsMap;
        sfcnPeriod = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnPeriod);
        sfcnOffset = (time_T *) malloc(1 * sizeof(time_T));
        ss_VALIDATE_MEMORY(rts,sfcnOffset);
        sfcnTsMap = (int_T *) malloc(1 * sizeof(int_T ));
        ss_VALIDATE_MEMORY(rts,sfcnTsMap);
        (void) memset((void*)sfcnPeriod, 0,
                      sizeof(time_T)*1);
        (void) memset((void*)sfcnOffset, 0,
                      sizeof(time_T)*1);
        ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
        ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
        _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

        /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

        {
          struct _ssBlkInfo2 *blkInfo2 = (struct _ssBlkInfo2 *) malloc(sizeof(
              struct _ssBlkInfo2));
          ss_VALIDATE_MEMORY(rts,blkInfo2);
          ssSetBlkInfo2Ptr(childS, blkInfo2);
        }

        ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

        _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

        /* Allocate memory of model methods 2 */
        {
          struct _ssSFcnModelMethods2 *methods2 = (struct _ssSFcnModelMethods2 *)
            malloc(sizeof(struct _ssSFcnModelMethods2));
          ss_VALIDATE_MEMORY(rts,methods2);
          ssSetModelMethods2(childS, methods2);
        }

        /* Allocate memory of model methods 3 */
        {
          struct _ssSFcnModelMethods3 *methods3 = (struct _ssSFcnModelMethods3 *)
            malloc(sizeof(struct _ssSFcnModelMethods3));
          ss_VALIDATE_MEMORY(rts,methods3);
          ssSetModelMethods3(childS, methods3);
        }

        /* Allocate memory for states auxilliary information */
        {
          struct _ssStatesInfo2 *statesInfo2 = (struct _ssStatesInfo2 *) malloc
            (sizeof(struct _ssStatesInfo2));
          ssPeriodicStatesInfo* periodicStatesInfo = (ssPeriodicStatesInfo*)
            malloc(sizeof(ssPeriodicStatesInfo));
          ss_VALIDATE_MEMORY(rts,statesInfo2);
          ssSetStatesInfo2(childS, statesInfo2);
          ss_VALIDATE_MEMORY(rts,periodicStatesInfo);
          ssSetPeriodicStatesInfo(childS, periodicStatesInfo);
        }

        ssSetRegNumInputPortsFcn(childS, (_ssRegNumInputPortsFcn)
          RegNumInputPorts);
        ssSetRegNumInputPortsFcnArg(childS,childS);

        /* inputs */
        {
          struct _ssPortInputs *inputPortInfo =
            (struct _ssPortInputs *) calloc(4, sizeof(struct _ssPortInputs));
          ss_VALIDATE_MEMORY(rts,inputPortInfo);
          _ssSetNumInputPorts(childS, 4);
          ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

          /* port 0 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->Switch_lo[2];
            _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 0, 1);
            ssSetInputPortWidth(childS, 0, 1);
          }

          /* port 1 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
            _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 1, 1);
            ssSetInputPortWidth(childS, 1, 1);
          }

          /* port 2 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant4_Value_m;
            _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 2, 1);
            ssSetInputPortWidth(childS, 2, 1);
          }

          /* port 3 */
          {
            real32_T const **sfcnUPtrs = (real32_T const **)
              malloc(1 * sizeof(real32_T *));
            ss_VALIDATE_MEMORY(rts,sfcnUPtrs);
            sfcnUPtrs[0] = (real32_T const *)
              &AFCS_MODEL1_ConstP.Constant2_Value_o;
            _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
            _ssSetInputPortNumDimensions(childS, 3, 1);
            ssSetInputPortWidth(childS, 3, 1);
          }
        }

        ssSetRegNumOutputPortsFcn(childS, (_ssRegNumOutputPortsFcn)
          RegNumOutputPorts);
        ssSetRegNumOutputPortsFcnArg(childS,childS);

        /* outputs */
        {
          struct _ssPortOutputs *outputPortInfo = (struct _ssPortOutputs *)
            calloc(1, sizeof(struct _ssPortOutputs));
          ss_VALIDATE_MEMORY(rts,outputPortInfo);
          ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
          _ssSetNumOutputPorts(childS, 1);

          /* port 0 */
          {
            _ssSetOutputPortNumDimensions(childS, 0, 1);
            ssSetOutputPortWidth(childS, 0, 1);
            _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T *)
              ssGetLocalBlockIO(rts))->GeneratedSFunction15_e));
          }
        }

        /* path info */
        _ssSetModelName(childS, "StickGradientDeadZone_sf");
        _ssSetPath(childS,
                   "AFCS_MODEL1/AFCS_MODEL1/GNC/Pilot/Stick Gradient DeadZone/Generated S-Function15");
        if (ssGetRTModel(rts) == (NULL)) {
          _ssSetParentSS(childS, rts);
          _ssSetRootSS(childS, ssGetRootSS(rts));
        } else {
          ssSetRTModel(childS,ssGetRTModel(rts));
          _ssSetParentSS(childS, (NULL));
          _ssSetRootSS(childS, childS);
        }

        ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);
        (childS)->regDataType.arg1 = ((void *)(childS));
        (childS)->regDataType.registerFcn = ((OldRegisterDataType)
          FcnSetErrorStatus);
        (childS)->regDataType.getSizeFcn = ((GetDataTypeSize)FcnSetErrorStatus);
        (childS)->regDataType.getZeroFcn = ((GetDataTypeZero)FcnSetErrorStatus);
        (childS)->regDataType.getNameFcn = ((GetDataTypeName)FcnSetErrorStatus);
        (childS)->regDataType.getIdFcn = ((GetDataTypeId)FcnSetErrorStatus);

        /* registration */
#if defined(MATLAB_MEX_FILE)

        {
          int_T i;
          mxArray *plhs[1];
          mxArray *prhs[4];
          double *pr;
          volatile int_T *intS = (int_T *)&childS;
          int_T addrlen = sizeof(SimStruct *);
          int_T m = addrlen/sizeof(int_T) + 1;
          prhs[0] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[1] = mxCreateDoubleMatrix(m,1,mxREAL);
          pr = mxGetPr(prhs[1]);
          for (i = 0; i < m - 1; i++) {
            pr[i] = (double)intS[i];
          }

          pr[i] = (double)SIMSTRUCT_VERSION_LEVEL2;
          prhs[2] = mxCreateDoubleMatrix(0,0,mxREAL);
          prhs[3] = mxCreateDoubleMatrix(1,1,mxREAL);

          /* Reset port dimensions info functions because the S-function
           * and accelerator mex-files explicitly set their dimensions,
           * i.e., they are not dynamically sized. For this case, the
           * mex-file is responsible for the dimensions info memory
           * and Simulink should not free it. This is achieved by
           * setting the following two methods to NULL.
           */
          ssSetRegInputPortDimensionInfoFcn(childS, (NULL));
          ssSetRegOutputPortDimensionInfoFcn(childS, (NULL));

          /*
           * Setup function pointers and call mdlInitializeSizes via
           * simulink.c
           */
          mexCallMATLAB(1, plhs, 4, prhs, "StickGradientDeadZone_sf");
          mxDestroyArray(plhs[0]);
          mxDestroyArray(prhs[0]);
          mxDestroyArray(prhs[1]);
          mxDestroyArray(prhs[2]);
          mxDestroyArray(prhs[3]);
        }

#else

        {
          StickGradientDeadZone_sf(childS);
          sfcnInitializeSizes(childS);
        }

#endif

        sfcnInitializeSampleTimes(childS);

        /* adjust sample time */
        ssSetSampleTime(childS, 0, 0.0);
        ssSetOffsetTime(childS, 0, 0.0);
        sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

        /* set compiled values of dynamic vector attributes */
        ssSetNumNonsampledZCs(childS, 0);

        /* Update connectivity flags for each port */
        _ssSetInputPortConnected(childS, 0, 1);
        _ssSetInputPortConnected(childS, 1, 1);
        _ssSetInputPortConnected(childS, 2, 1);
        _ssSetInputPortConnected(childS, 3, 1);
        _ssSetOutputPortConnected(childS, 0, 1);
        _ssSetOutputPortBeingMerged(childS, 0, 0);

        /* Update the BufferDstPort flags for each input port */
        _ssSetInputPortBufferDstPort(childS, 0, -1);
        _ssSetInputPortBufferDstPort(childS, 1, -1);
        _ssSetInputPortBufferDstPort(childS, 2, -1);
        _ssSetInputPortBufferDstPort(childS, 3, -1);
      }
    }
  }

  return (NULL);
}
