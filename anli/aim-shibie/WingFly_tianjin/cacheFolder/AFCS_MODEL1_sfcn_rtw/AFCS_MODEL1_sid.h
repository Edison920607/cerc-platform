/*
 * AFCS_MODEL1_sid.h
 *
 * Code generation for model "AFCS_MODEL1_sf".
 *
 * Model version              : 1.995
 * Simulink Coder version : 8.10 (R2016a) 10-Feb-2016
 * C source code generated on : Wed Aug 11 17:17:39 2021
 *
 * Target selection: rtwsfcn.tlc
 * Note: GRT includes extra infrastructure and instrumentation for prototyping
 * Embedded hardware selection: ARM Compatible->ARM Cortex
 * Emulation hardware selection:
 *    Differs from embedded hardware (MATLAB Host)
 * Code generation objectives: Unspecified
 * Validation result: Not run
 *
 * SOURCES: AFCS_MODEL1_sf.c AFCS_MODEL1_CodeReuseSubsystem.c
 */

/* statically allocated instance data for model: AFCS_MODEL1 */
{
  extern const ConstB_AFCS_MODEL1_T AFCS_MODEL1_Invariant;

  {
    /* Local SimStruct for the generated S-Function */
    static LocalS slS;
    LocalS *lS = &slS;
    ssSetUserData(rts, lS);

    /* block I/O */
    {
      static B_AFCS_MODEL1_T sfcnB;
      void *b = (real_T *) &sfcnB;
      ssSetLocalBlockIO(rts, b);
      (void) memset(b, 0,
                    sizeof(B_AFCS_MODEL1_T));

      {
        ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->FixPtSwitch = (0ULL);
        ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Output = (0ULL);
        ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->FixPtSum1 = (0ULL);
        ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Quaternions[0] = 0.0F;
        ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Quaternions[1] = 0.0F;
        ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Quaternions[2] = 0.0F;
        ((B_AFCS_MODEL1_T *) ssGetLocalBlockIO(rts))->Quaternions[3] = 0.0F;
      }
    }

    _ssSetConstBlockIO(rts, &AFCS_MODEL1_Invariant);

    /* previous zero-crossing states */
    {
      int_T i;
      static PrevZCX_AFCS_MODEL1_T AFCS_MODEL1_PrevZCX;
      ZCSigState *zc = (ZCSigState *) &AFCS_MODEL1_PrevZCX;
      _ssSetPrevZCSigState(rts, zc);
      for (i = 0; i < 2; i++) {
        zc[i] = UNINITIALIZED_ZCSIG;
      }
    }

    /* model checksums */
    ssSetChecksumVal(rts, 0, 3122258030U);
    ssSetChecksumVal(rts, 1, 1365478836U);
    ssSetChecksumVal(rts, 2, 3803939167U);
    ssSetChecksumVal(rts, 3, 1395178863U);

    {
      /* child S-Function registration */
      ssSetNumSFunctions(rts, 170);

      /* register each child */
      {
        static SimStruct childSFunctions[170];
        static SimStruct *childSFunctionPtrs[170];
        (void) memset((void *)&childSFunctions[0], 0,
                      sizeof(childSFunctions));
        _ssSetSFunctions(rts, &childSFunctionPtrs[0]);

        {
          int_T i;
          for (i = 0; i < 170; i++) {
            _ssSetSFunction(rts, i, &childSFunctions[i]);
          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S174>/Generated S-Function (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 0);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion3_h;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch4;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/FixthrustL/ lag filter/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 147))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 148))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 374))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 375))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S186>/Generated S-Function (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 1);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum_hq;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_c));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/Saturation Limiter1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S188>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 2);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_c;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant1_Value_i;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_c5));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S185>/Generated S-Function (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 3);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_j;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_c5;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_n));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/Lead lag/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 149))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 150))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 376))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 377))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S187>/Generated S-Function (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 4);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_n;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled110;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Product1_g));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/Saturation Limiter3/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S189>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 5);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_n;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant2_Value_c;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_j));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S184>/Generated S-Function (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 6);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_j;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add2;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add2;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add_g1;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add1;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_j;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Product1_g));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/Integrator Limited/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 151))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 152))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 378))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 379))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S183>/Generated S-Function (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 7);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_j;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_b;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_k));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VtControl/ lag filter/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 153))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 154))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 380))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 381))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S179>/Generated S-Function (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 8);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum_mj;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_g));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/Saturation Limiter1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S181>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 9);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_g;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant1_Value_i;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_j5));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S178>/Generated S-Function (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 10);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_lt;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_j5;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_e));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/Lead lag/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 155))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 156))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 382))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 383))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S180>/Generated S-Function (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 11);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_e;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled110;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Product1_g));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/Saturation Limiter3/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S182>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 12);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_e;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant2_Value_c;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_b));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S177>/Generated S-Function (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 13);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_lt;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add2_d;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add2_d;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add_l;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add1_g;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_b;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Product1_g));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/Integrator Limited/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 157))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 158))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 384))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 385))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S176>/Generated S-Function (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 14);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_lt;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_k;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_a;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_m));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apthrustLcontrol/VcControl/ lag filter/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 159))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 160))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 386))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 387))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S92>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 15);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum6;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Saturation Limiter2/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S96>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 16);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant22_Value;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_o));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S93>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 17);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Divide2;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Switch6_d));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Saturation Limiter3/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S97>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 18);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_o;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_jq));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/gain4/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S89>/Generated S-Function3 (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 19);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion3_c;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum8;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum8;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_jq;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Switch6_d));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Integrator Limited1/Generated S-Function3");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 162))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 163))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 389))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 390))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S91>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 20);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_j;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_h));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S95>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 21);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_h;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant13_Value_n;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation8));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S90>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 22);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion3_c;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Divide;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Lead lag/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 164))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 165))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 391))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 392))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S94>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 23);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product1_m;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product_pp;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_b));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/Saturation Limiter4/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S87>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 24);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion3_c;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_b;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/AltLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 166))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 167))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 393))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 394))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S114>/Generated S-Function (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 25);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product1_m;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product_pp;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_kz));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/NzControl/Saturation Limiter1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S113>/Generated S-Function (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 26);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion_gv;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_kz;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/NzControl/ lag filter/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 168))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 169))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 395))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 396))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S86>/Generated S-Function6 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 27);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_f;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction6));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/Generated S-Function6");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S119>/Generated S-Function (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 28);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction6;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_n0));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/Saturation Limiter/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S121>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 29);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_n0;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_k1));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S118>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 30);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_p;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant10_Value_a;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_k1;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_m));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/Lead lag/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 170))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 171))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 397))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 398))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S120>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 31);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_m;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product1_m;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product_pp;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation8));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S117>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 32);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_p;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_e;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_e;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum2_eb;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_d));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/ lag filter1/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 172))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 173))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 399))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 400))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S122>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 33);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction4_d;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Switch6_d));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S116>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 34);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_p;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum3_l;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_f));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/ThetaLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 174))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 175))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 401))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 402))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S102>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 35);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_l;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_n));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S104>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 36);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_n;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant13_Value_n;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_b1));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S105>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 37);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_b1;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_h));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/gain4/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S100>/Generated S-Function3 (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 38);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_c;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant19_Value;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant76_Value;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_h;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation8));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/Integrator Limited1/Generated S-Function3");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 176))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 177))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 403))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 404))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S101>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 39);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_c;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Divide_e;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_j));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/Lead lag/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 178))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 179))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 405))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 406))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S103>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 40);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_j;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product1_m;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product_pp;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_e));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/Saturation Limiter2/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S98>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 41);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_c;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_e;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_c));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/GamaLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 180))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 181))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 407))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 408))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S109>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 42);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_i;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_g));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S111>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 43);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_g;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant13_Value_n;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_nx));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S112>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 44);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_nx;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_d));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/gain4/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S107>/Generated S-Function3 (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 45);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion4_k;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant19_Value;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant76_Value;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_d;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation8));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/Integrator Limited1/Generated S-Function3");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 182))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 183))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 409))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 410))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S108>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 46);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion4_k;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Divide_ez;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_b));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/Lead lag/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 184))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 185))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 411))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 412))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S110>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 47);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_b;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product1_m;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product_pp;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_l));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/Saturation Limiter2/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S106>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 48);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion4_k;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_aj;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_l;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_n));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/HdotLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 186))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 187))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 413))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 414))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S81>/Generated S-Function5 (Fader_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 49);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->MultiportSwitch2;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->MultiportSwitch2;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch9;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->appc));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Fader_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/appcLcontrol/Fader/Generated S-Function5");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[7];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[7];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 7);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 289))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 290))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 2, 0);
            _ssSetDWork(childS, 2, &((real32_T*) ssGetDWork(rts, 291))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT32);
            ssSetDWorkComplexSignal(childS, 3, 0);
            _ssSetDWork(childS, 3, &((int32_T*) ssGetDWork(rts, 332))[0]);

            /* DWORK4 */
            ssSetDWorkWidth(childS, 4, 1);
            ssSetDWorkDataType(childS, 4,SS_INT32);
            ssSetDWorkComplexSignal(childS, 4, 0);
            _ssSetDWork(childS, 4, &((int32_T*) ssGetDWork(rts, 333))[0]);

            /* DWORK5 */
            ssSetDWorkWidth(childS, 5, 1);
            ssSetDWorkDataType(childS, 5,SS_INT8);
            ssSetDWorkComplexSignal(childS, 5, 0);
            _ssSetDWork(childS, 5, &((int8_T*) ssGetDWork(rts, 517))[0]);

            /* DWORK6 */
            ssSetDWorkWidth(childS, 6, 1);
            ssSetDWorkDataType(childS, 6,SS_INT8);
            ssSetDWorkComplexSignal(childS, 6, 0);
            _ssSetDWork(childS, 6, &((int8_T*) ssGetDWork(rts, 518))[0]);
          }

          /* registration */
          Fader_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: Fader */
          {
            SimStruct *rts = childS;

#include "Fader_sfcn_rtw/Fader_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S130>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 50);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion5_n;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_b));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 189))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 190))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 417))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 418))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S125>/Generated S-Function6 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 51);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_lf;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction6_h));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/Generated S-Function6");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S134>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 52);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction6_h;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_c));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/Saturation Limiter/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S135>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 53);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_c;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_hw));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S136>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 54);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_hw;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->MinMax));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S137>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 55);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->UnitDelay1_k;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_a));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/gain8/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.005);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S132>/Generated S-Function3 (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 56);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion3_d;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum2_c;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum2_c;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant29_Value;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant30_Value;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum11;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction3));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/Integrator Limited/Generated S-Function3");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 192))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 193))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 419))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 420))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S133>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 57);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion3_d;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum_c;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_f));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/Lead lag/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 194))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 195))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 421))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 422))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S131>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 58);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion3_d;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_f;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_m));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PhiLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 196))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 197))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 423))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 424))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S155>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 59);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Divide_c;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_o));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Saturation Limiter2/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.005);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S128>/Generated S-Function6 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 60);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum3_g;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction6_g));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Generated S-Function6");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S154>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 61);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction6_g;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_m));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S158>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 62);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_m;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled122;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_f));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S152>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 63);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_h;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum4_d;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum4_d;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_f;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation2_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Lead lag1/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 198))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 199))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 425))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 426))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S128>/Generated S-Function1 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 64);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_g;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_hp));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S153>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 65);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_hp;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_oq));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Saturation Limiter/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S156>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 66);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_oq;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_ex));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S157>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 67);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_ex;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_nh));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S150>/Generated S-Function3 (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 68);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_h;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant29_Value;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant30_Value;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_nh;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation2_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Integrator Limited/Generated S-Function3");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 200))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 201))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 427))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 428))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S151>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 69);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_h;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum_d;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_i));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/Lead lag/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 202))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 203))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 429))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 430))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S149>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 70);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_h;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_i;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_dc));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsiLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 204))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 205))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 431))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 432))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S145>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 71);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Divide_l;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Saturation Limiter2/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.005);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S127>/Generated S-Function6 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 72);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum3_c;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction6_a));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Generated S-Function6");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S144>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 73);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction6_a;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_l1));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S148>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 74);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_l1;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_cv));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S142>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 75);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_p;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum4_i;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum4_i;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_cv;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_c));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Lead lag1/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 206))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 207))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 433))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 434))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S143>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 76);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_c;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation2_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Saturation Limiter/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S127>/Generated S-Function1 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 77);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_ga;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_bh));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S146>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 78);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_bh;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_ma));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S147>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 79);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_ma;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_ck));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S140>/Generated S-Function3 (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 80);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_p;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant29_Value;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant30_Value;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_ck;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation2_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Integrator Limited/Generated S-Function3");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 208))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 209))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 435))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 436))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S141>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 81);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_p;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum_mz;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_n));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/Lead lag/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 210))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 211))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 437))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 438))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S139>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 82);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_p;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_n;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_cg));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/PsdLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 212))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 213))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 439))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 440))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S164>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 83);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum2_hh;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_n1));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter3/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S168>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 84);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_n1;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled123;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_fb));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/gain3/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S169>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 85);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_fb;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_ok));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/gain4/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S160>/Generated S-Function3 (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 86);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion4_g;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled111;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled112;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_ok;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation2_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Integrator Limited1/Generated S-Function3");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 214))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 215))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 441))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 442))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S129>/Generated S-Function6 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 87);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum3_cy;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction6_h3));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Generated S-Function6");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S162>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 88);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction6_h3;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_oh));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S167>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 89);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_oh;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_mc));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S161>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 90);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_mc;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation2_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S129>/Generated S-Function1 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 91);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_lk;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_f));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S166>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 92);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_f;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation2_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S159>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 93);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion4_g;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bg;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum_oh;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_mj));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 216))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 217))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 443))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 444))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S123>/Generated S-Function5 (Fader_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 94);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->MultiportSwitch2_k;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->MultiportSwitch2_k;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch9;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->aprc));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Fader_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/Fader/Generated S-Function5");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[7];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[7];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 7);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 292))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 293))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 2, 0);
            _ssSetDWork(childS, 2, &((real32_T*) ssGetDWork(rts, 294))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT32);
            ssSetDWorkComplexSignal(childS, 3, 0);
            _ssSetDWork(childS, 3, &((int32_T*) ssGetDWork(rts, 334))[0]);

            /* DWORK4 */
            ssSetDWorkWidth(childS, 4, 1);
            ssSetDWorkDataType(childS, 4,SS_INT32);
            ssSetDWorkComplexSignal(childS, 4, 0);
            _ssSetDWork(childS, 4, &((int32_T*) ssGetDWork(rts, 335))[0]);

            /* DWORK5 */
            ssSetDWorkWidth(childS, 5, 1);
            ssSetDWorkDataType(childS, 5,SS_INT8);
            ssSetDWorkComplexSignal(childS, 5, 0);
            _ssSetDWork(childS, 5, &((int8_T*) ssGetDWork(rts, 519))[0]);

            /* DWORK6 */
            ssSetDWorkWidth(childS, 6, 1);
            ssSetDWorkDataType(childS, 6,SS_INT8);
            ssSetDWorkComplexSignal(childS, 6, 0);
            _ssSetDWork(childS, 6, &((int8_T*) ssGetDWork(rts, 520))[0]);
          }

          /* registration */
          Fader_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: Fader */
          {
            SimStruct *rts = childS;

#include "Fader_sfcn_rtw/Fader_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S163>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 95);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Divide_c2;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_nk));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter2/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.005);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S165>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 96);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Divide1_d;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled115;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_d));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/aprcLcontrol/RwyLControl/Saturation Limiter4/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S190>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 97);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion_f;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled124;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_k));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 219))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 220))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 446))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 447))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S191>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 98);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion3_l;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled124;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch7;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/ lag filter1/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 221))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 222))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 448))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 449))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S193>/Generated S-Function (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 99);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum3_g5;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_bb));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S198>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 100);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_bb;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_mq));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S199>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 101);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_mq;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled122;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_k5));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S197>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 102);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_e;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_k5;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_h));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/Lead lag1/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 223))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 224))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 450))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 451))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S196>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 103);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_e;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled124;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_h;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_a));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/PsiControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 225))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 226))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 452))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 453))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S204>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 104);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->r_n;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation8));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S203>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 105);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum2_eo;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_ov));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/Saturation Limiter3/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S206>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 106);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_ov;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->MinMax));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/gain3/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S194>/Generated S-Function6 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 107);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum3_k;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction6_aa));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/Generated S-Function6");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S202>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 108);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction6_aa;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_dm));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S205>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 109);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_dm;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_pk));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S201>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 110);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_j;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_pk;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->MinMax));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/Lead lag1/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 227))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 228))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 454))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 455))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S200>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 111);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_j;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled124;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_jf;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_k;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_j));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/apycLcontrol/RwyLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 229))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 230))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 456))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 457))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S69>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 112);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion_p;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_fz;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_fz;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_pd));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 232))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 233))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 459))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 460))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S70>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 113);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion2_b;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_fz;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_fz;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Gain_k;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_h));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/ lag filter1/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 234))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 235))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 461))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 462))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S77>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 114);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum2_b;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled119;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_i));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/Saturation Limiter3/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S79>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 115);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_i;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation2_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/gain3/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S72>/Generated S-Function6 (Res180_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 116);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum3_ca;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction6_j));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Res180_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/Generated S-Function6");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Res180_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: Res180 */
          {
            SimStruct *rts = childS;

#include "Res180_sfcn_rtw/Res180_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S76>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 117);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction6_j;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled120;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled121;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_k));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S78>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 118);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_k;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_cq));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S75>/Generated S-Function2 (LeadLagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 119);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_jy;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_fz;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_fz;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_cq;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction2_m5));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LeadLagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/Lead lag1/Generated S-Function2");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 236))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 237))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 463))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 464))[0]);
          }

          /* registration */
          LeadLagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: LeadLagFilter */
          {
            SimStruct *rts = childS;

#include "LeadLagFilter_sfcn_rtw/LeadLagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S74>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 120);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReuseS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->DataTypeConversion1_jy;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled107;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_fz;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_fz;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction2_m5;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_cw));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/Autopilot/NWScontrol/RwyLControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 238))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 239))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 465))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 466))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S209>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 121);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_lr;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_oi));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/Saturation Limiter/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S208>/Generated S-Function (RateLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 122);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[5];
            _ssSetNumInputPorts(childS, 5);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReus_b[5];
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled123;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_oi;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[2];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 2);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_o1));
            }

            /* port 1 */
            {
              _ssSetOutputPortNumDimensions(childS, 1, 1);
              ssSetOutputPortWidth(childS, 1, 1);
              _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_o2));
            }
          }

          /* path info */
          _ssSetModelName(childS, "RateLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/Rate Limiter/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[3];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[3];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 3);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 240))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_INT8);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 467))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 468))[0]);
          }

          /* registration */
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 1, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);
          _ssSetOutputPortBeingMerged(childS, 1, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);

          /* Instance data for generated S-Function: RateLimiter */
          {
            SimStruct *rts = childS;

#include "RateLimiter_sfcn_rtw/RateLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S241>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 123);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled126;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation_ll;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation_ll;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation_ll;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation8));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/ lag filter2/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 241))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 242))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 469))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 470))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S245>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 124);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum_ot;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product_pf;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_fe));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain3/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S246>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 125);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_fe;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_gq));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain4/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S239>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 126);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Ny;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Ny;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Ny;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_kq));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 243))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 244))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 471))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 472))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S242>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 127);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction4_kq;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled108;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation8));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S240>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 128);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled126;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation1_o;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation1_o;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation1_o;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_ab));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/ lag filter1/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 245))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 246))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 473))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 474))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S238>/Generated S-Function8 (WashoutFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 129);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation1_o;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation1_o;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction4_ab;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction8));
            }
          }

          /* path info */
          _ssSetModelName(childS, "WashoutFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/ high pass filter/Generated S-Function8");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 247))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 248))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 475))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 476))[0]);
          }

          /* registration */
          WashoutFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: WashoutFilter */
          {
            SimStruct *rts = childS;

#include "WashoutFilter_sfcn_rtw/WashoutFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S244>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 130);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction8;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant23_Value;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->MinMax));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S243>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 131);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum5;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product2_d;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_dc));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/lat/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S225>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 132);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_dd;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled130;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled131;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_en));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S223>/Generated S-Function7 (RateLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 133);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[5];
            _ssSetNumInputPorts(childS, 5);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->TmpSignalConversionAtCodeReus_b[4];
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled125;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_en;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[2];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 2);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation8));
            }

            /* port 1 */
            {
              _ssSetOutputPortNumDimensions(childS, 1, 1);
              ssSetOutputPortWidth(childS, 1, 1);
              _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2));
            }
          }

          /* path info */
          _ssSetModelName(childS, "RateLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/Rate Limiter1/Generated S-Function7");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[3];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[3];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 3);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 249))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_INT8);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 477))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 478))[0]);
          }

          /* registration */
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 1, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);
          _ssSetOutputPortBeingMerged(childS, 1, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);

          /* Instance data for generated S-Function: RateLimiter */
          {
            SimStruct *rts = childS;

#include "RateLimiter_sfcn_rtw/RateLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S226>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 134);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_c;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled130;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled131;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_or));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/Saturation Limiter4/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S224>/Generated S-Function7 (RateLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 135);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[5];
            _ssSetNumInputPorts(childS, 5);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Gain1_o;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled125;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_or;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[2];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 2);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->drint));
            }

            /* port 1 */
            {
              _ssSetOutputPortNumDimensions(childS, 1, 1);
              ssSetOutputPortWidth(childS, 1, 1);
              _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2_i));
            }
          }

          /* path info */
          _ssSetModelName(childS, "RateLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/latTdaclda1/Rate Limiter3/Generated S-Function7");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[3];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[3];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 3);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 250))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_INT8);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 479))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 480))[0]);
          }

          /* registration */
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 1, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);
          _ssSetOutputPortBeingMerged(childS, 1, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);

          /* Instance data for generated S-Function: RateLimiter */
          {
            SimStruct *rts = childS;

#include "RateLimiter_sfcn_rtw/RateLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S252>/Generated S-Function8 (WashoutFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 136);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction8_p));
            }
          }

          /* path info */
          _ssSetModelName(childS, "WashoutFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/ high pass filter/Generated S-Function8");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 251))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 252))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 481))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 482))[0]);
          }

          /* registration */
          WashoutFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: WashoutFilter */
          {
            SimStruct *rts = childS;

#include "WashoutFilter_sfcn_rtw/WashoutFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S253>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 137);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled114;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_e;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_e;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_e;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_e));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/ lag filter/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 253))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 254))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 483))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 484))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S254>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 138);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled113;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction4_ms));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/ lag filter1/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 255))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 256))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 485))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 486))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S259>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 139);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction4_e;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->MinMax));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S260>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 140);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction4_ms;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled123;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation7));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S255>/Generated S-Function9 (NegativePass_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 141);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum2_hd;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation7));
            }
          }

          /* path info */
          _ssSetModelName(childS, "NegativePass_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/ negative pass1/Generated S-Function9");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          NegativePass_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: NegativePass */
          {
            SimStruct *rts = childS;

#include "NegativePass_sfcn_rtw/NegativePass_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S266>/Generated S-Function (WashoutFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 142);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Alfa_j;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Alfa_j;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Alfa_j;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_f5));
            }
          }

          /* path info */
          _ssSetModelName(childS, "WashoutFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim / high pass filter2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 257))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 258))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 487))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 488))[0]);
          }

          /* registration */
          WashoutFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: WashoutFilter */
          {
            SimStruct *rts = childS;

#include "WashoutFilter_sfcn_rtw/WashoutFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S268>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 143);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_f5;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->MinMax));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S265>/Generated S-Function8 (WashoutFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 144);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->q_k;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction8_e));
            }
          }

          /* path info */
          _ssSetModelName(childS, "WashoutFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim / high pass filter1/Generated S-Function8");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 259))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 260))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 489))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 490))[0]);
          }

          /* registration */
          WashoutFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: WashoutFilter */
          {
            SimStruct *rts = childS;

#include "WashoutFilter_sfcn_rtw/WashoutFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S269>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 145);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction8_e;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled133;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o1));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /gain10/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S267>/Generated S-Function (NegativePass_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 146);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum12;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_hl));
            }
          }

          /* path info */
          _ssSetModelName(childS, "NegativePass_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim / negative pass1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          NegativePass_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: NegativePass */
          {
            SimStruct *rts = childS;

#include "NegativePass_sfcn_rtw/NegativePass_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S270>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 147);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_hl;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o1));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /gain11/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S272>/Generated S-Function (PositivePass_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 148);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[1];
            _ssSetNumInputPorts(childS, 1);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum2_n;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_m5));
            }
          }

          /* path info */
          _ssSetModelName(childS, "PositivePass_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /positive pass1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          PositivePass_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);

          /* Instance data for generated S-Function: PositivePass */
          {
            SimStruct *rts = childS;

#include "PositivePass_sfcn_rtw/PositivePass_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S271>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 149);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_m5;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->MinMax));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/AlfaLim /gain9/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S261>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 150);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction8_p;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation9));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S262>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 151);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum6_j;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product1_j;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_l));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain3/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S258>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 152);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_l;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled130;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled131;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation9));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S263>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 153);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction_l;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled132;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation9));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain4/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S264>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 154);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->UnitDelay1_c;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_mt));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/gain8/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.005);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[1];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S257>/Generated S-Function3 (IntegratorLimited_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 155);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[7];
            _ssSetNumInputPorts(childS, 7);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum4_iv;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum4_iv;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add4;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Add5;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }

            /* port 6 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum11_c;
              _ssSetInputPortSignalPtrs(childS, 6, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 6, 1);
              ssSetInputPortWidth(childS, 6, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->deint));
            }
          }

          /* path info */
          _ssSetModelName(childS, "IntegratorLimited_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/PIDonControl/Integrator Limited/Generated S-Function3");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 263))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 264))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 492))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 493))[0]);
          }

          /* registration */
          IntegratorLimited_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetInputPortConnected(childS, 6, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);
          _ssSetInputPortBufferDstPort(childS, 6, -1);

          /* Instance data for generated S-Function: IntegratorLimited */
          {
            SimStruct *rts = childS;

#include "IntegratorLimited_sfcn_rtw/IntegratorLimited_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S250>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 156);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_m;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled130;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled131;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_pc));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/Saturation Limiter4/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S249>/Generated S-Function7 (RateLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 157);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[5];
            _ssSetNumInputPorts(childS, 5);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Gain_i;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled125;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_pc;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[2];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 2);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->daint));
            }

            /* port 1 */
            {
              _ssSetOutputPortNumDimensions(childS, 1, 1);
              ssSetOutputPortWidth(childS, 1, 1);
              _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2_i2));
            }
          }

          /* path info */
          _ssSetModelName(childS, "RateLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/lon/Rate Limiter3/Generated S-Function7");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[3];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[3];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 3);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 265))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_INT8);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 494))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 495))[0]);
          }

          /* registration */
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 1, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);
          _ssSetOutputPortBeingMerged(childS, 1, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);

          /* Instance data for generated S-Function: RateLimiter */
          {
            SimStruct *rts = childS;

#include "RateLimiter_sfcn_rtw/RateLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S275>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 158);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_i;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_hf));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/sb/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S274>/Generated S-Function7 (RateLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 159);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[5];
            _ssSetNumInputPorts(childS, 5);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled133;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_hf;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[2];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 2);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->Saturation9));
            }

            /* port 1 */
            {
              _ssSetOutputPortNumDimensions(childS, 1, 1);
              ssSetOutputPortWidth(childS, 1, 1);
              _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2_f));
            }
          }

          /* path info */
          _ssSetModelName(childS, "RateLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/sb/Rate Limiter1/Generated S-Function7");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[3];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[3];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 3);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 266))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_INT8);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 496))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 497))[0]);
          }

          /* registration */
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 1, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);
          _ssSetOutputPortBeingMerged(childS, 1, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);

          /* Instance data for generated S-Function: RateLimiter */
          {
            SimStruct *rts = childS;

#include "RateLimiter_sfcn_rtw/RateLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S215>/Generated S-Function4 (LagFilter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 160);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[6];
            _ssSetNumInputPorts(childS, 6);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled126;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation1_o;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation1_o;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }

            /* port 5 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation_p;
              _ssSetInputPortSignalPtrs(childS, 5, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 5, 1);
              ssSetInputPortWidth(childS, 5, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o1));
            }
          }

          /* path info */
          _ssSetModelName(childS, "LagFilter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/NwsBrk/ lag filter2/Generated S-Function4");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[4];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[4];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 4);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 267))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((real32_T*) ssGetDWork(rts, 268))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 498))[0]);

            /* DWORK3 */
            ssSetDWorkWidth(childS, 3, 1);
            ssSetDWorkDataType(childS, 3,SS_INT8);
            ssSetDWorkComplexSignal(childS, 3, 0);
            ssSetDWorkUsedAsDState(childS, 3, 1);
            _ssSetDWork(childS, 3, &((int8_T*) ssGetDWork(rts, 499))[0]);
          }

          /* registration */
          LagFilter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetInputPortConnected(childS, 5, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);
          _ssSetInputPortBufferDstPort(childS, 5, -1);

          /* Instance data for generated S-Function: LagFilter */
          {
            SimStruct *rts = childS;

#include "LagFilter_sfcn_rtw/LagFilter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S218>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 161);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum_b;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled133;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_ka));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/NwsBrk/gain3/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S217>/Generated S-Function1 (SaturationLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 162);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[3];
            _ssSetNumInputPorts(childS, 3);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_bw;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product4_o;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Product3_d;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction1_hx));
            }
          }

          /* path info */
          _ssSetModelName(childS, "SaturationLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/NwsBrk/Saturation Limiter1/Generated S-Function1");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          SaturationLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);

          /* Instance data for generated S-Function: SaturationLimiter */
          {
            SimStruct *rts = childS;

#include "SaturationLimiter_sfcn_rtw/SaturationLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S216>/Generated S-Function7 (RateLimiter_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 163);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[5];
            _ssSetNumInputPorts(childS, 5);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static int8_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (int8_T const *) &AFCS_MODEL1_ConstP.pooled143;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled106;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled134;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->dtCAS;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }

            /* port 4 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->GeneratedSFunction1_hx;
              _ssSetInputPortSignalPtrs(childS, 4, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 4, 1);
              ssSetInputPortWidth(childS, 4, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[2];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 2);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o1));
            }

            /* port 1 */
            {
              _ssSetOutputPortNumDimensions(childS, 1, 1);
              ssSetOutputPortWidth(childS, 1, 1);
              _ssSetOutputPortSignal(childS, 1, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction7_o2_k));
            }
          }

          /* path info */
          _ssSetModelName(childS, "RateLimiter_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/CAS/NwsBrk/Rate Limiter1/Generated S-Function7");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* work vectors */
          {
            static struct _ssDWorkRecord dWorkRecord[3];
            static struct _ssDWorkAuxRecord dWorkAuxRecord[3];
            ssSetSFcnDWork(childS, dWorkRecord);
            ssSetSFcnDWorkAux(childS, dWorkAuxRecord);
            _ssSetNumDWork(childS, 3);

            /* DWORK0 */
            ssSetDWorkWidth(childS, 0, 1);
            ssSetDWorkDataType(childS, 0,SS_SINGLE);
            ssSetDWorkComplexSignal(childS, 0, 0);
            ssSetDWorkUsedAsDState(childS, 0, 1);
            _ssSetDWork(childS, 0, &((real32_T*) ssGetDWork(rts, 269))[0]);

            /* DWORK1 */
            ssSetDWorkWidth(childS, 1, 1);
            ssSetDWorkDataType(childS, 1,SS_INT8);
            ssSetDWorkComplexSignal(childS, 1, 0);
            ssSetDWorkUsedAsDState(childS, 1, 1);
            _ssSetDWork(childS, 1, &((int8_T*) ssGetDWork(rts, 500))[0]);

            /* DWORK2 */
            ssSetDWorkWidth(childS, 2, 1);
            ssSetDWorkDataType(childS, 2,SS_INT8);
            ssSetDWorkComplexSignal(childS, 2, 0);
            ssSetDWorkUsedAsDState(childS, 2, 1);
            _ssSetDWork(childS, 2, &((int8_T*) ssGetDWork(rts, 501))[0]);
          }

          /* registration */
          RateLimiter_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetInputPortConnected(childS, 4, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortConnected(childS, 1, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);
          _ssSetOutputPortBeingMerged(childS, 1, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);
          _ssSetInputPortBufferDstPort(childS, 4, -1);

          /* Instance data for generated S-Function: RateLimiter */
          {
            SimStruct *rts = childS;

#include "RateLimiter_sfcn_rtw/RateLimiter_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S279>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 164);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Sum1_o;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_gq4));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/GNCinit1/apinit/lon/gain/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S280>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 165);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation_bq;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled123;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_dw));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/GNCinit1/apinit/lon/gain1/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S281>/Generated S-Function (Gain_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 166);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[2];
            _ssSetNumInputPorts(childS, 2);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Saturation_bq;
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled105;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction_d4));
            }
          }

          /* path info */
          _ssSetModelName(childS, "Gain_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Level/CodeReuseSubsystem/GNCinit1/apinit/lon/gain2/Generated S-Function");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          Gain_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);

          /* Instance data for generated S-Function: Gain */
          {
            SimStruct *rts = childS;

#include "Gain_sfcn_rtw/Gain_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S306>/Generated S-Function15 (StickGradientDeadZone_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 167);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[4];
            _ssSetNumInputPorts(childS, 4);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_lo[1];
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant2_Value_o;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction15));
            }
          }

          /* path info */
          _ssSetModelName(childS, "StickGradientDeadZone_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Pilot/Stick Gradient DeadZone2/Generated S-Function15");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          StickGradientDeadZone_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);

          /* Instance data for generated S-Function: StickGradientDeadZone */
          {
            SimStruct *rts = childS;

#include "StickGradientDeadZone_sfcn_rtw/StickGradientDeadZone_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S305>/Generated S-Function15 (StickGradientDeadZone_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 168);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[4];
            _ssSetNumInputPorts(childS, 4);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_lo[0];
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled109;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant2_Value_o;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction15_i));
            }
          }

          /* path info */
          _ssSetModelName(childS, "StickGradientDeadZone_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Pilot/Stick Gradient DeadZone1/Generated S-Function15");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          StickGradientDeadZone_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);

          /* Instance data for generated S-Function: StickGradientDeadZone */
          {
            SimStruct *rts = childS;

#include "StickGradientDeadZone_sfcn_rtw/StickGradientDeadZone_sid.h"

          }
        }

        /* RTW Generated Level2 S-Function Block: AFCS_MODEL1/<S304>/Generated S-Function15 (StickGradientDeadZone_sf) */
        {
          SimStruct *childS = ssGetSFunction(rts, 169);

          /* timing info */
          static time_T sfcnPeriod[1];
          static time_T sfcnOffset[1];
          static int_T sfcnTsMap[1];
          (void) memset((void*)sfcnPeriod, 0,
                        sizeof(time_T)*1);
          (void) memset((void*)sfcnOffset, 0,
                        sizeof(time_T)*1);
          ssSetSampleTimePtr(childS, &sfcnPeriod[0]);
          ssSetOffsetTimePtr(childS, &sfcnOffset[0]);
          _ssSetSampleTimeTaskIDPtr(childS, sfcnTsMap);

          /* Set up the mdlInfo pointer */
# ifdef USE_RTMODEL

          {
            static struct _ssBlkInfo2 _blkInfo2;
            struct _ssBlkInfo2 *blkInfo2 = &_blkInfo2;
            ssSetBlkInfo2Ptr(childS, blkInfo2);
          }

          ssSetRTWSfcnInfo(childS, ssGetRTWSfcnInfo(rts));

# else

          _ssSetMdlInfoPtr(childS, ssGetMdlInfoPtr(rts));

# endif                                /* USE_RTMODEL */

          /* Allocate memory of model methods 2 */
          {
            static struct _ssSFcnModelMethods2 methods2;
            ssSetModelMethods2(childS, &methods2);
          }

          /* Allocate memory of model methods 3 */
          {
            static struct _ssSFcnModelMethods3 methods3;
            ssSetModelMethods3(childS, &methods3);
          }

          /* Allocate memory for states auxilliary information */
          {
            static struct _ssStatesInfo2 statesInfo2;
            static ssPeriodicStatesInfo periodicStatesInfo;
            ssSetStatesInfo2(childS, &statesInfo2);
            ssSetPeriodicStatesInfo(childS, &periodicStatesInfo);
          }

          /* inputs */
          {
            static struct _ssPortInputs inputPortInfo[4];
            _ssSetNumInputPorts(childS, 4);
            ssSetPortInfoForInputs(childS, &inputPortInfo[0]);

            /* port 0 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &((B_AFCS_MODEL1_T *)
                ssGetLocalBlockIO(rts))->Switch_lo[2];
              _ssSetInputPortSignalPtrs(childS, 0, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 0, 1);
              ssSetInputPortWidth(childS, 0, 1);
            }

            /* port 1 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *) &AFCS_MODEL1_ConstP.pooled116;
              _ssSetInputPortSignalPtrs(childS, 1, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 1, 1);
              ssSetInputPortWidth(childS, 1, 1);
            }

            /* port 2 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant4_Value_m;
              _ssSetInputPortSignalPtrs(childS, 2, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 2, 1);
              ssSetInputPortWidth(childS, 2, 1);
            }

            /* port 3 */
            {
              static real32_T const *sfcnUPtrs[1];
              sfcnUPtrs[0] = (real32_T const *)
                &AFCS_MODEL1_ConstP.Constant2_Value_o;
              _ssSetInputPortSignalPtrs(childS, 3, (InputPtrsType)&sfcnUPtrs[0]);
              _ssSetInputPortNumDimensions(childS, 3, 1);
              ssSetInputPortWidth(childS, 3, 1);
            }
          }

          /* outputs */
          {
            static struct _ssPortOutputs outputPortInfo[1];
            ssSetPortInfoForOutputs(childS, &outputPortInfo[0]);
            _ssSetNumOutputPorts(childS, 1);

            /* port 0 */
            {
              _ssSetOutputPortNumDimensions(childS, 0, 1);
              ssSetOutputPortWidth(childS, 0, 1);
              _ssSetOutputPortSignal(childS, 0, ((real32_T *) &((B_AFCS_MODEL1_T
                *) ssGetLocalBlockIO(rts))->GeneratedSFunction15_e));
            }
          }

          /* path info */
          _ssSetModelName(childS, "StickGradientDeadZone_sf");
          _ssSetPath(childS,
                     "AFCS_MODEL1/AFCS_MODEL1/GNC/Pilot/Stick Gradient DeadZone/Generated S-Function15");
          if (ssGetRTModel(rts) == (NULL)) {
            _ssSetParentSS(childS, rts);
            _ssSetRootSS(childS, ssGetRootSS(rts));
          } else {
            ssSetRTModel(childS,ssGetRTModel(rts));
            _ssSetParentSS(childS, (NULL));
            _ssSetRootSS(childS, childS);
          }

          ssSetVersion(childS, SIMSTRUCT_VERSION_LEVEL2);

          /* registration */
          StickGradientDeadZone_sf(childS);
          sfcnInitializeSizes(childS);
          sfcnInitializeSampleTimes(childS);

          /* adjust sample time */
          ssSetSampleTime(childS, 0, 0.0);
          ssSetOffsetTime(childS, 0, 0.0);
          sfcnTsMap[0] = ssGetSampleTimeTaskIDPtr(rts)[0];

          /* set compiled values of dynamic vector attributes */
          ssSetNumNonsampledZCs(childS, 0);

          /* Update connectivity flags for each port */
          _ssSetInputPortConnected(childS, 0, 1);
          _ssSetInputPortConnected(childS, 1, 1);
          _ssSetInputPortConnected(childS, 2, 1);
          _ssSetInputPortConnected(childS, 3, 1);
          _ssSetOutputPortConnected(childS, 0, 1);
          _ssSetOutputPortBeingMerged(childS, 0, 0);

          /* Update the BufferDstPort flags for each input port */
          _ssSetInputPortBufferDstPort(childS, 0, -1);
          _ssSetInputPortBufferDstPort(childS, 1, -1);
          _ssSetInputPortBufferDstPort(childS, 2, -1);
          _ssSetInputPortBufferDstPort(childS, 3, -1);

          /* Instance data for generated S-Function: StickGradientDeadZone */
          {
            SimStruct *rts = childS;

#include "StickGradientDeadZone_sfcn_rtw/StickGradientDeadZone_sid.h"

          }
        }
      }
    }
  }
}
